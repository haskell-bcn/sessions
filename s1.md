# Summary

* Introduction / Presentation
    * Who, What, How & When
    * History of Haskell
* Pure functional programming
    * Related concepts
    * Pros & Cons
    * Different approaches
* A brief introduction to Haskell
    * Expressions
    * Types
    * Functions
    * ...
* Haskell Tools
    * Building/project tools
    * Other

# Who & What

* Organizers
    * Antoni Silvestre, Software Engineer @ TID
    * Dani Pous, Software Engineer @ TID
    * Jordi Aranda, Data Engineer @ BBVA D&A
* Main goals
    * To learn & share:
        * Haskell & friends
        * Pure functional programming
        * Category Theory
    * Meet people around with common interests
    * Open community: share your ideas and expectations

# How & When

* Talks
* Katas
* Discussions (libraries, papers, etc.)
    * Any proposal !?
* ~ Monthly meetings
* Recorded sessions (with slides/code samples available)

# History of Haskell

* Based on Lambda Calculus
* Started ~20 years ago
* Statically typed

# Pure functional programming

From Wikipedia:

> In computer science, <b>functional programming</b> is a programming paradigm
<br> that treats computation as the <b>evaluation</b> of mathematical <b>functions</b>
<br> and avoids <b>changing-state</b> and <b>mutable data</b>. (...) ($\to$ <b>functional</b>)

> It is a <b>declarative</b> (the what) programming paradigm, which means
<br> programming is done with <b>expressions</b> or <b>declarations</b>
<br> instead of <b>statements</b> (the how). (...)

> In functional code, the <b>output value</b> of a function <b>depends only</b>
<br> on the arguments that are <b>input</b> to the function, so calling a
<br> function $f$ twice with the same value for an argument $x$ will produce
<br> the same result $f(x)$ each time. (...) ($\to$ <b>purity</b>)

# Related concepts

* Purity ($\to$ referential transparency):
    * Every function $f$ is a function in the mathematical sense:
        * Every input has its corresponding output
        * Same input produces same output, *always*
        * Order does not matter
        * Easy concurrency
* Laziness:
    * Nothing evaluates unless necessary
    * Inner-most expressions first (**call by name**)
    * Allows:
        * Infinite data structures
        * Recursive types
        * Recursive functions
    * Category theory (**functor**, **monoid**, **monad**, and many other buzzwords)
* Reasoning ($\gets$ purity):
    * >The central idea of pure functional programming is to structure
    <br> our programs in such a way that we can reason about them as
    <br> a system of equations just like we can in mathematics.

# Pros & Cons

* Advantages:
    * Maintainability ($\to$ happiness)
    * Testability
    * Increase of productivity
    * Code reuse, easier refactoring
    * Great levels of abstraction (use carefully)
    * Better reasoning

* Disadvantages:
    * For developers, steep learning curve
    * For companies, small pool of developers

# Different approaches

* Functional focuses on what and not how
* Expressions instead of statements
* Denotational semantics (code $\to$ mathematical expressions) instead of
<br> operational semantics (code $\to$ abstract machine statements)

# A brief introduction to Haskell

* Expressions
* Types
* Functions
* Infix operators
* Values declaration
* Basic data types
* Typeclasses
* Functional patterns

# Expressions

* Everything in Haskell is an *expression* or *declaration*
* Basic unit of a Haskell program
* Expressions may be:
    * Values
    * Combination of values
    * Functions applied to values
* Expressions *evaluate* to a *result*
* The following are all expressions:
    ```haskell
    1
    1 + 1
    "Hello, world!"
    ```

# Types

* Every expression has a *type*
* Types are a way of categorizing values
* We have different types for:
    * Numbers (whether they are integers, fractional numbers, etc.)
    * Boolean values
    * Characters or strings
    * Lists
    * Many other ADTs
* We can inspect the type of an expression using the `:t` command in the `GHCi`
    ```haskell
    Prelude> :t 1
    1 :: Num a => a
    Prelude> :t True
    True :: Bool
    Prelude> :t "Haskell"
    "Haskell" :: [Char]
    ```
* We can define new data types using the `data` keyword. For instance:
    ```haskell
    data Booly = Falsy | Truthy
    Prelude> :t Falsy
    Falsy :: Booly
    Prelude> :t Truthy
    Truthy :: Booly
    ```

# Functions (I)

* A function is an expression that is applied to an argument (or parameter) and always
<br> returns a result
* They always evaluate to the same result when given the same values
* As in **lambda calculus**, all functions take one argument at a time and return only
<br> one result ($\to$ currying)
* When defining functions, capitalization matters: they always start with a lowercase letter.
<br> Variables also start lowercase

# Functions (II)

* To define a function or value in `GCHi`, you must use `let`:
    ```haskell
    Prelude> let double x = x * 2
    ```
* Functions also have a type!
    ```haskell
    :t double
    double :: Num a => a -> a
    ```
* Let's inspect this function:
    ```
    double x    =   x * 2
    [1]   [2]  [3]   [4]
    ```
    1. Name of the function we are defining
    2. Argument of our function ("head" of a lambda)
    3. The `=` is used to define (or **declare**) values and functions. This is not how we
    <br> define equality between two values in Haskell
* Calling the function by name and introducing a value for the $x$ argument makes our
<br> function a **reducible** expression:
    ```haskell
    Prelude> double 2
    4
    ```
* We can define **lambdas** using anonymous function syntax:
    ```haskell 
    Prelude> (\x -> x) 0
    0
    ```

# Infix operators

* Default is **prefix syntax**, meaning that the function being applied is at the beginning
<br> of the expression rather than in the middle
* Not all functions are prefix though, e.g. arithmetic operators
* All operators are functions, not all functions are operators
    ```haskell
    Prelude> 1 + 1
    2
    Prelude> (+) 1 1
    2
    ```
* As in math, there is a default associativty and precedence for infix operators. We can ask
<br> `GHCi` for information such as this by using the `:i` command:
    ```haskell
    Prelude> :i (+)
    class Num a where
      (+) :: a -> a -> a
      ...
          -- Defined in ‘GHC.Num’
    infixl 6 +
    Prelude> :i (*)
    class Num a where
      ...
      (*) :: a -> a -> a
       ...
          -- Defined in ‘GHC.Num’
    infixl 7 *
    ```

# Values declaration

* Use `=` to define a variable or function
* Bound names (variable, function, etc.) are:
    * **Immutable**: only one binding for symbol and scope
    * **Order independent**: order of bindings does not matter in source code
    * **Lazy**: bindings are only evaluated when necessary
    * **Recursive**: the bound symbol is in the scope of its own definition
